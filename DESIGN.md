# Design Notes

## Data Model

I defined dataclasses for Accounts, Transactions, and each report generated by the application. I used an enum to enforce correct account types, any type other than `"credit"` or `"debit"` is not possible to enter into the program.

I force the user to include unique numeric identifiers for each account and transaction. These ids are also used to identify which accounts are involved in each transaction. In a real application, this provides the benefit that Account names can be changed without needing to modify more than one location in storage. However, in a real implementation the burden of generating unique ids wouldn't be passed to the user.

In a real world situation, the application should generate these ids internally, and let the user refer to resources by their names. I struggled to reason about how to do that, so I punted on that particular problem for the sake of time.

## Architecture

For this project, I divided code into the domains of storage, application logic, and user interface.

### Storage

Storage manages all persistent data. In `database/database.py` I implemented a basic in-memory storage solution, but I tried to design an interface in `AbstractDatabase`  that could readily be replaced by a sqlite based implementation. The in memory database itself has minimal data validation, because the validation logic should be the same regardless of the storage implementation.

I chose an in-memory storage implementation because it was simplest to implement under the time constraints. If I return to this project, one of my first tasks will be to build a sqlite based storage layer for persistent storage.

#### Data Access Objects

There were a number of invariants I wanted to enforce on any stored data.
* Account names and IDs should be unique.
* Transactions should be balanced
* Transactions should reference existing accounts

I used 'data access object' type classes (`AccountDao` and `TransactionDao`) to enforce these invariants on the boundary between application logic and storage. The `Ledger` class has no direct dependency on the storage layer, and instead must interact through the data access objects.

To my mind this boundary is the only reasonable place to enforce these invariants. Any earlier, and some bug might later break the invariant. Any later, and the validation logic needs to be duplicated for each storage implementation.

### Application Logic

Pretty much all of the Application logic lives in `app/ledger.py`. The application logic is simple for most of the methods, just passing data between the user interface and the data access objects.

Asside from that, the application layer tracks the running ballance of each account, and handles most of the logic of building reports.

### User Interface

I built a shell based command line interface for this project in `cli/ledger_shell.py` using standard library classes. I chose a command line interface for simplicity of implementation, and used a shell because it seemed to be the easiest way to maintain a persistent session for the sake of the in-memory data storage.

The role of the user interface is just to translate I/O for the user. I tried to keep any application logic out of the shell implementation so that the shell could possibly be replaced by another interface, e.g. a REST API.

### Edge Cases

In retrospect there are a few edge cases I haven't fully handled.

1. empty transactions
   * A transaction with no accounts is technically balanced, but probably shouldn't be accepted as valid input.
   * As currently written my code would accept such a transaction, I'll make a note to change it
2. Negative balances
   * It is currently possible for a user to input a balanced transaction that would push an individual account's balance below zero. This could easily be nonsensical, because accounts like cash or inventory couldn't meaningfully be negative.
   * I chose not to treat this as a special case. Ultimately some transactions may be reported to the balance sheet out of order, so if a transaction causes an account to go negative, it is still possible for another transaction might be added to fix it.